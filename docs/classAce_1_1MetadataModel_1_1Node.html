<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Accelerated Computation Engine: Ace::MetadataModel::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Accelerated Computation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceAce.html">Ace</a></li><li class="navelem"><a class="el" href="classAce_1_1MetadataModel.html">MetadataModel</a></li><li class="navelem"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html">Node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classAce_1_1MetadataModel_1_1Node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ace::MetadataModel::Node Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ace__metadatamodel__node_8h_source.html">ace_metadatamodel_node.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Ace::MetadataModel::Node:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classAce_1_1MetadataModel_1_1Node.png" usemap="#Ace::MetadataModel::Node_map" alt=""/>
  <map id="Ace::MetadataModel::Node_map" name="Ace::MetadataModel::Node_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a262f428c19a379d1ced184a9b01c7cae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a262f428c19a379d1ced184a9b01c7cae">Node</a> (<a class="el" href="classEMetadata.html#ac579ecaf6ce6181b77c842663db69c96">EMetadata::Type</a> <a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a3fe9279a0d235b233436ec104593a747">type</a>=<a class="el" href="classEMetadata.html#ac579ecaf6ce6181b77c842663db69c96af2785659f0bc07c6ff6774d6c23a7946">EMetadata::Null</a>, QObject *<a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a524368dad9cfd4198fbb1f7ced50643a">parent</a>=nullptr)</td></tr>
<tr class="separator:a262f428c19a379d1ced184a9b01c7cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606233b8739daacbd1bbdf5633f2d8f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a606233b8739daacbd1bbdf5633f2d8f1">Node</a> (const <a class="el" href="classEMetadata.html">EMetadata</a> &amp;<a class="el" href="classAce_1_1MetadataModel_1_1Node.html#acacb08a39c279557bc4ef4d616c4b743">meta</a>, QObject *<a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a524368dad9cfd4198fbb1f7ced50643a">parent</a>=nullptr)</td></tr>
<tr class="separator:a606233b8739daacbd1bbdf5633f2d8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818696b1e172be53c4bda264507c493e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a818696b1e172be53c4bda264507c493e">Node</a> (const <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">Node</a> &amp;object)</td></tr>
<tr class="separator:a818696b1e172be53c4bda264507c493e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc178ace437116b235a35f12db725587"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#afc178ace437116b235a35f12db725587">isBytes</a> () const</td></tr>
<tr class="separator:afc178ace437116b235a35f12db725587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdca88d092b5d1e5e11591b377c1e3a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#abdca88d092b5d1e5e11591b377c1e3a6">isEditable</a> () const</td></tr>
<tr class="separator:abdca88d092b5d1e5e11591b377c1e3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b38944ff67a19bf7d972b7dd3b7b082"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a8b38944ff67a19bf7d972b7dd3b7b082">isContainer</a> () const</td></tr>
<tr class="separator:a8b38944ff67a19bf7d972b7dd3b7b082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d0bd210a3592db754c4ad19005ae65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a29d0bd210a3592db754c4ad19005ae65">isArray</a> () const</td></tr>
<tr class="separator:a29d0bd210a3592db754c4ad19005ae65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7080f1da010f86fb1a2e2fa2d6725b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a9c7080f1da010f86fb1a2e2fa2d6725b">isObject</a> () const</td></tr>
<tr class="separator:a9c7080f1da010f86fb1a2e2fa2d6725b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8375d30641300d84ee8350b606241aa8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a8375d30641300d84ee8350b606241aa8">size</a> () const</td></tr>
<tr class="separator:a8375d30641300d84ee8350b606241aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524368dad9cfd4198fbb1f7ced50643a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html">MetadataModel::Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a524368dad9cfd4198fbb1f7ced50643a">parent</a> () const</td></tr>
<tr class="separator:a524368dad9cfd4198fbb1f7ced50643a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab255098ff0a637c9ded3fb688da34e06"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#ab255098ff0a637c9ded3fb688da34e06">key</a> () const</td></tr>
<tr class="separator:ab255098ff0a637c9ded3fb688da34e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab666c66cc34af114fab91afa5909c9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#aab666c66cc34af114fab91afa5909c9f">setKey</a> (const QString &amp;newKey)</td></tr>
<tr class="separator:aab666c66cc34af114fab91afa5909c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe9279a0d235b233436ec104593a747"><td class="memItemLeft" align="right" valign="top">QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a3fe9279a0d235b233436ec104593a747">type</a> () const</td></tr>
<tr class="separator:a3fe9279a0d235b233436ec104593a747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731dbbdd4708e8749da33a3b8a926a01"><td class="memItemLeft" align="right" valign="top">QByteArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a731dbbdd4708e8749da33a3b8a926a01">bytes</a> () const</td></tr>
<tr class="separator:a731dbbdd4708e8749da33a3b8a926a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacb08a39c279557bc4ef4d616c4b743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEMetadata.html">EMetadata</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#acacb08a39c279557bc4ef4d616c4b743">meta</a> () const</td></tr>
<tr class="separator:acacb08a39c279557bc4ef4d616c4b743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108f24d8ab8706a7a5acaa9a24946ee4"><td class="memItemLeft" align="right" valign="top">QVariant&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a108f24d8ab8706a7a5acaa9a24946ee4">value</a> () const</td></tr>
<tr class="separator:a108f24d8ab8706a7a5acaa9a24946ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5cf0f526d4c4ec752ddda84b03472c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a3d5cf0f526d4c4ec752ddda84b03472c">setValue</a> (const QVariant &amp;<a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a108f24d8ab8706a7a5acaa9a24946ee4">value</a>)</td></tr>
<tr class="separator:a3d5cf0f526d4c4ec752ddda84b03472c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755f66cc4c7a23489d61d71d660dbae9"><td class="memItemLeft" align="right" valign="top">QList&lt; <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">MetadataModel::Node</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a755f66cc4c7a23489d61d71d660dbae9">arrayBegin</a> () const</td></tr>
<tr class="separator:a755f66cc4c7a23489d61d71d660dbae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22036c48b75df99fb5817ae8f8ee591"><td class="memItemLeft" align="right" valign="top">QList&lt; <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">MetadataModel::Node</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#aa22036c48b75df99fb5817ae8f8ee591">arrayEnd</a> () const</td></tr>
<tr class="separator:aa22036c48b75df99fb5817ae8f8ee591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378af515dc31f4b17a2448be648d9eca"><td class="memItemLeft" align="right" valign="top">QMap&lt; QString, <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">MetadataModel::Node</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a378af515dc31f4b17a2448be648d9eca">objectBegin</a> () const</td></tr>
<tr class="separator:a378af515dc31f4b17a2448be648d9eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3981a7c07048708f2cf3ed57dad2e1"><td class="memItemLeft" align="right" valign="top">QMap&lt; QString, <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">MetadataModel::Node</a> * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a2f3981a7c07048708f2cf3ed57dad2e1">objectEnd</a> () const</td></tr>
<tr class="separator:a2f3981a7c07048708f2cf3ed57dad2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676050ee37a2dedfd8ddae6f3048ac23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html">MetadataModel::Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a676050ee37a2dedfd8ddae6f3048ac23">get</a> (int <a class="el" href="classAce_1_1MetadataModel.html#a6a325a97a0d05c132683a0a2b32cb1be">index</a>) const</td></tr>
<tr class="separator:a676050ee37a2dedfd8ddae6f3048ac23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70461d774e4d41934b2554885f5254d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a70461d774e4d41934b2554885f5254d0">indexOf</a> (const <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">Node</a> *pointer) const</td></tr>
<tr class="separator:a70461d774e4d41934b2554885f5254d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1ea94a2174100798a424c49958f684"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a2c1ea94a2174100798a424c49958f684">contains</a> (const QString &amp;<a class="el" href="classAce_1_1MetadataModel_1_1Node.html#ab255098ff0a637c9ded3fb688da34e06">key</a>) const</td></tr>
<tr class="separator:a2c1ea94a2174100798a424c49958f684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c74efd71cf4c7baa72badd34d638b98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a5c74efd71cf4c7baa72badd34d638b98">getFutureIndex</a> (const QString &amp;<a class="el" href="classAce_1_1MetadataModel_1_1Node.html#ab255098ff0a637c9ded3fb688da34e06">key</a>) const</td></tr>
<tr class="separator:a5c74efd71cf4c7baa72badd34d638b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dc1e198d9a00b665d15d7f2616849d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">MetadataModel::Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#ae4dc1e198d9a00b665d15d7f2616849d">copy</a> (int <a class="el" href="classAce_1_1MetadataModel.html#a6a325a97a0d05c132683a0a2b32cb1be">index</a>)</td></tr>
<tr class="separator:ae4dc1e198d9a00b665d15d7f2616849d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358119d6a20184aded9ae60046b2c851"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">MetadataModel::Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a358119d6a20184aded9ae60046b2c851">cut</a> (int <a class="el" href="classAce_1_1MetadataModel.html#a6a325a97a0d05c132683a0a2b32cb1be">index</a>)</td></tr>
<tr class="separator:a358119d6a20184aded9ae60046b2c851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8411677b329b5cd00c793ea60db0a0a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a8411677b329b5cd00c793ea60db0a0a0">insertArray</a> (int <a class="el" href="classAce_1_1MetadataModel.html#a6a325a97a0d05c132683a0a2b32cb1be">index</a>, std::unique_ptr&lt; <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">Node</a> &gt; &amp;&amp;node)</td></tr>
<tr class="separator:a8411677b329b5cd00c793ea60db0a0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62c86782b0aec5bac8a0c4717172d95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#ac62c86782b0aec5bac8a0c4717172d95">insertObject</a> (const QString &amp;<a class="el" href="classAce_1_1MetadataModel_1_1Node.html#ab255098ff0a637c9ded3fb688da34e06">key</a>, std::unique_ptr&lt; <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">Node</a> &gt; &amp;&amp;node)</td></tr>
<tr class="separator:ac62c86782b0aec5bac8a0c4717172d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b8d75c8029dad5aec423c791b1b5f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html#a01b8d75c8029dad5aec423c791b1b5f3">remove</a> (int <a class="el" href="classAce_1_1MetadataModel.html#a6a325a97a0d05c132683a0a2b32cb1be">index</a>)</td></tr>
<tr class="separator:a01b8d75c8029dad5aec423c791b1b5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a single metadata node within the metadata model. The reason this class must exist as a wrapper around the metadata class is because the model must work with pointers for arrays and objects while the metadata classes do not use pointers. The node can be any possible metadata class. If it is an array or object it uses its own custom qt containers that hold pointers instead of metadata arrays or objects. The nodes are also Qt Objects to allow for easy memory cleanup. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a262f428c19a379d1ced184a9b01c7cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262f428c19a379d1ced184a9b01c7cae">&#9670;&nbsp;</a></span>Node() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MetadataModel::Node::Node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEMetadata.html#ac579ecaf6ce6181b77c842663db69c96">EMetadata::Type</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classEMetadata.html#ac579ecaf6ce6181b77c842663db69c96af2785659f0bc07c6ff6774d6c23a7946">EMetadata::Null</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a new node object with the given qt object as its parent, if any.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The metadata type of this new node.</td></tr>
    <tr><td class="paramname">parent</td><td>The parent of this new node, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a606233b8739daacbd1bbdf5633f2d8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606233b8739daacbd1bbdf5633f2d8f1">&#9670;&nbsp;</a></span>Node() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MetadataModel::Node::Node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEMetadata.html">EMetadata</a> &amp;&#160;</td>
          <td class="paramname"><em>meta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a new node object with the given metadata value and the given qt object as its parent, if any. If the metadata given is an array or object then the metadata values contained within are not copied. This is because nodes store their values in an entirely different manner than the metadata class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meta</td><td>The metadata value of this new node.</td></tr>
    <tr><td class="paramname">parent</td><td>The parent of this new node, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a818696b1e172be53c4bda264507c493e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818696b1e172be53c4bda264507c493e">&#9670;&nbsp;</a></span>Node() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MetadataModel::Node::Node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a new node object as a copy of the given object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The other node object that is copied to this one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a755f66cc4c7a23489d61d71d660dbae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755f66cc4c7a23489d61d71d660dbae9">&#9670;&nbsp;</a></span>arrayBegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">MetadataModel::Node</a> * &gt;::const_iterator MetadataModel::Node::arrayBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns first constant iterator to node pointer in this node's internal array of pointers. If this node is not an array type this list will always be empty.</p>
<dl class="section return"><dt>Returns</dt><dd>First node pointer constant iterator in array. </dd></dl>

</div>
</div>
<a id="aa22036c48b75df99fb5817ae8f8ee591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22036c48b75df99fb5817ae8f8ee591">&#9670;&nbsp;</a></span>arrayEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QList&lt; <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">MetadataModel::Node</a> * &gt;::const_iterator MetadataModel::Node::arrayEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns end of list constant iterator in this node's internal array of pointers. If this node is not an array type this list will always be empty.</p>
<dl class="section return"><dt>Returns</dt><dd>End of list constant iterator of array. </dd></dl>

</div>
</div>
<a id="a731dbbdd4708e8749da33a3b8a926a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731dbbdd4708e8749da33a3b8a926a01">&#9670;&nbsp;</a></span>bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QByteArray MetadataModel::Node::bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the byte array of this node. If this node is not a bytes type then an empty byte array is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>Byte array of this node, if any. </dd></dl>

</div>
</div>
<a id="a2c1ea94a2174100798a424c49958f684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1ea94a2174100798a424c49958f684">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MetadataModel::Node::contains </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests whether this node's internal mapping of node pointers already contains the given key. If this node is not an object type false is always returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The given key to be tested if it already exists within this node's mapping.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the given key already exists, else returns false. </dd></dl>

</div>
</div>
<a id="ae4dc1e198d9a00b665d15d7f2616849d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4dc1e198d9a00b665d15d7f2616849d">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">MetadataModel::Node</a> &gt; MetadataModel::Node::copy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a copy of this node's child at the given index. If the given index does not exist or this node is not a container type then a null pointer is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of child node that is copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to copy of child node or null pointer if no such child exists. </dd></dl>

</div>
</div>
<a id="a358119d6a20184aded9ae60046b2c851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358119d6a20184aded9ae60046b2c851">&#9670;&nbsp;</a></span>cut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">MetadataModel::Node</a> &gt; MetadataModel::Node::cut </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cuts this node's child at the given index, returning its pointer and removing it form this node's list of children. If the given index does not exist or this node is not a container type then a null pointer is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of child node that is cut.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to child node removed or null pointer if no such child exists. </dd></dl>

</div>
</div>
<a id="a676050ee37a2dedfd8ddae6f3048ac23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676050ee37a2dedfd8ddae6f3048ac23">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html">MetadataModel::Node</a> * MetadataModel::Node::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the node pointer contains in this node's internal container, map or array, with the given index. If this node is not a container type or the index is out of range then null is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the requested node pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classAce_1_1MetadataModel_1_1Node.html">Node</a> pointer with given index, if any. </dd></dl>

</div>
</div>
<a id="a5c74efd71cf4c7baa72badd34d638b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c74efd71cf4c7baa72badd34d638b98">&#9670;&nbsp;</a></span>getFutureIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MetadataModel::Node::getFutureIndex </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This will return the index a new node would be inserted into this node's internal map with the given key if this is an object type. If this node is not an object then -1 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The given key to test for indexing position within the map.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index where the given key would be inserted. </dd></dl>

</div>
</div>
<a id="a70461d774e4d41934b2554885f5254d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70461d774e4d41934b2554885f5254d0">&#9670;&nbsp;</a></span>indexOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MetadataModel::Node::indexOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds what index the given node pointer exists within this node if at all. If this node is not a container or the pointer is not matched to any of its children then -1 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>The node pointer that will be matched against any children this node contains.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index where match to node pointer is found or -1 if no match is found. </dd></dl>

</div>
</div>
<a id="a8411677b329b5cd00c793ea60db0a0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8411677b329b5cd00c793ea60db0a0a0">&#9670;&nbsp;</a></span>insertArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MetadataModel::Node::insertArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">Node</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a new node with the given pointer into this node's internal array at the given index if this node is an array type. If this node is not an array type this does nothing but free then given node pointer. If the index is less than 0 the new node is prepended to the array. If the index is greater than or equal to its size it is appended to the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index where the new node is inserted.</td></tr>
    <tr><td class="paramname">node</td><td>Pointer to the new node that is inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac62c86782b0aec5bac8a0c4717172d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62c86782b0aec5bac8a0c4717172d95">&#9670;&nbsp;</a></span>insertObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MetadataModel::Node::insertObject </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">Node</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a new node with the given pointer into this node's internal mapping with the given key. If the key already exists the node pointer is overwritten with the new node pointer, freeing the old node's memory. If this node is not an object type this does nothing but free the given node pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key where the new node that is inserted to in the map.</td></tr>
    <tr><td class="paramname">node</td><td>The pointer to the new node that is inserted into the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29d0bd210a3592db754c4ad19005ae65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d0bd210a3592db754c4ad19005ae65">&#9670;&nbsp;</a></span>isArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MetadataModel::Node::isArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests if this node is an array.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true of this is an array, else returns false. </dd></dl>

</div>
</div>
<a id="afc178ace437116b235a35f12db725587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc178ace437116b235a35f12db725587">&#9670;&nbsp;</a></span>isBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MetadataModel::Node::isBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests if this node is a bytes type.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true of this node is a bytes type else returns false. </dd></dl>

</div>
</div>
<a id="a8b38944ff67a19bf7d972b7dd3b7b082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b38944ff67a19bf7d972b7dd3b7b082">&#9670;&nbsp;</a></span>isContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MetadataModel::Node::isContainer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests if this node is either an array or an object.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this is an array or object, else returns false. </dd></dl>

</div>
</div>
<a id="abdca88d092b5d1e5e11591b377c1e3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdca88d092b5d1e5e11591b377c1e3a6">&#9670;&nbsp;</a></span>isEditable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MetadataModel::Node::isEditable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests if this node's metadata is editable as a string.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if this node is editable else returns false. </dd></dl>

</div>
</div>
<a id="a9c7080f1da010f86fb1a2e2fa2d6725b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7080f1da010f86fb1a2e2fa2d6725b">&#9670;&nbsp;</a></span>isObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MetadataModel::Node::isObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests of this node is an object.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true of this is an object, else returns false. </dd></dl>

</div>
</div>
<a id="ab255098ff0a637c9ded3fb688da34e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab255098ff0a637c9ded3fb688da34e06">&#9670;&nbsp;</a></span>key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString MetadataModel::Node::key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the key or name for this node in relation to its parent. If its parent is an array the index is returned as a string.</p>
<dl class="section return"><dt>Returns</dt><dd>The key or index number of this node. </dd></dl>

</div>
</div>
<a id="acacb08a39c279557bc4ef4d616c4b743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacb08a39c279557bc4ef4d616c4b743">&#9670;&nbsp;</a></span>meta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEMetadata.html">EMetadata</a> MetadataModel::Node::meta </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This returns the metadata value for this node.</p>
<dl class="section return"><dt>Returns</dt><dd>This node's metadata value. </dd></dl>

</div>
</div>
<a id="a378af515dc31f4b17a2448be648d9eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378af515dc31f4b17a2448be648d9eca">&#9670;&nbsp;</a></span>objectBegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QMap&lt; QString, <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">MetadataModel::Node</a> * &gt;::const_iterator MetadataModel::Node::objectBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns first constant iterator to node pointer in this node's internal map of pointers. If this node is not an object type this list will always be empty.</p>
<dl class="section return"><dt>Returns</dt><dd>First node pointer constant iterator in map. </dd></dl>

</div>
</div>
<a id="a2f3981a7c07048708f2cf3ed57dad2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3981a7c07048708f2cf3ed57dad2e1">&#9670;&nbsp;</a></span>objectEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QMap&lt; QString, <a class="el" href="classAce_1_1MetadataModel_1_1Node.html">MetadataModel::Node</a> * &gt;::const_iterator MetadataModel::Node::objectEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns end of list constant iterator in this node's internal mapping of pointers. If this node is not an object type this list will always be empty.</p>
<dl class="section return"><dt>Returns</dt><dd>End of list constant iterator of map. </dd></dl>

</div>
</div>
<a id="a524368dad9cfd4198fbb1f7ced50643a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524368dad9cfd4198fbb1f7ced50643a">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAce_1_1MetadataModel_1_1Node.html">MetadataModel::Node</a> * MetadataModel::Node::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns this node's parent. If this is the root node then null is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to this node's parent unless this node is root. </dd></dl>

</div>
</div>
<a id="a01b8d75c8029dad5aec423c791b1b5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b8d75c8029dad5aec423c791b1b5f3">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MetadataModel::Node::remove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes and deletes this node's child with the given index. This will work if the node is an array or an object type. If this node is not a container type or the index is out of range this does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the child node to be removed and deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab666c66cc34af114fab91afa5909c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab666c66cc34af114fab91afa5909c9f">&#9670;&nbsp;</a></span>setKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MetadataModel::Node::setKey </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>newKey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This sets the key of this node to a new value. If this node's parent is not an object type or the key already exists then false is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newKey</td><td>The new key for this node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true on success or false on failure. </dd></dl>

</div>
</div>
<a id="a3d5cf0f526d4c4ec752ddda84b03472c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5cf0f526d4c4ec752ddda84b03472c">&#9670;&nbsp;</a></span>setValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MetadataModel::Node::setValue </td>
          <td>(</td>
          <td class="paramtype">const QVariant &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the metadata value of this node if it is not a container type. If it is a container or null type then this will do nothing and return immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>New value this node's metadata will be set to if it is not a container type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if value was successfully set else returns false if no value was set. </dd></dl>

</div>
</div>
<a id="a8375d30641300d84ee8350b606241aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8375d30641300d84ee8350b606241aa8">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MetadataModel::Node::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of children this node contains. This works for any metadata type. If this node is not a container type then 0 is always returned.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of children, if any, this node contains. </dd></dl>

</div>
</div>
<a id="a3fe9279a0d235b233436ec104593a747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe9279a0d235b233436ec104593a747">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString MetadataModel::Node::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the metadata type for this node as a string.</p>
<dl class="section return"><dt>Returns</dt><dd>Metadata type of this node. </dd></dl>

</div>
</div>
<a id="a108f24d8ab8706a7a5acaa9a24946ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108f24d8ab8706a7a5acaa9a24946ee4">&#9670;&nbsp;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QVariant MetadataModel::Node::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the metadata value of this node if it is not a container or bytes type. If this node is a container type then a string reporting the number of nodes it holds is returned. If this node is a bytes type then a string informing the user this is an image is returned.</p>
<dl class="section return"><dt>Returns</dt><dd>Value of this node's metadata, or information about what it contains, or a plain string stating it is a bytes(image) type. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="ace__metadatamodel__node_8h_source.html">ace_metadatamodel_node.h</a></li>
<li>ace_metadatamodel_node.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
