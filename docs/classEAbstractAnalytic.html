<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Accelerated Computation Engine: EAbstractAnalytic Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Accelerated Computation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classEAbstractAnalytic-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">EAbstractAnalytic Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="eabstractanalytic_8h_source.html">eabstractanalytic.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for EAbstractAnalytic:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classEAbstractAnalytic.png" usemap="#EAbstractAnalytic_map" alt=""/>
  <map id="EAbstractAnalytic_map" name="EAbstractAnalytic_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEAbstractAnalytic_1_1Block.html">Block</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEAbstractAnalytic_1_1Input.html">Input</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEAbstractAnalytic_1_1OpenCL.html">OpenCL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEAbstractAnalytic_1_1Serial.html">Serial</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab518e9fe6dfd8f0fc82c15986ff0d873"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEAbstractAnalytic.html#ab518e9fe6dfd8f0fc82c15986ff0d873">size</a> () const =0</td></tr>
<tr class="separator:ab518e9fe6dfd8f0fc82c15986ff0d873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946ac98bb29b6c5e1d9f167511ae432e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEAbstractAnalytic.html#a946ac98bb29b6c5e1d9f167511ae432e">process</a> (const <a class="el" href="classEAbstractAnalytic_1_1Block.html">EAbstractAnalytic::Block</a> *result)=0</td></tr>
<tr class="separator:a946ac98bb29b6c5e1d9f167511ae432e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08ff1d8b6841ae84f7eae6a0eb724b6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEAbstractAnalytic_1_1Input.html">EAbstractAnalytic::Input</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEAbstractAnalytic.html#ab08ff1d8b6841ae84f7eae6a0eb724b6">makeInput</a> ()=0</td></tr>
<tr class="separator:ab08ff1d8b6841ae84f7eae6a0eb724b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36728ab171737200297c38d6b966010e"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classEAbstractAnalytic_1_1Block.html">EAbstractAnalytic::Block</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEAbstractAnalytic.html#a36728ab171737200297c38d6b966010e">makeWork</a> (int index) const</td></tr>
<tr class="separator:a36728ab171737200297c38d6b966010e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9057610ae34ff638d9641f411ba7c0"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classEAbstractAnalytic_1_1Block.html">EAbstractAnalytic::Block</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEAbstractAnalytic.html#a0d9057610ae34ff638d9641f411ba7c0">makeWork</a> () const</td></tr>
<tr class="separator:a0d9057610ae34ff638d9641f411ba7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89408851e50af49aee5281141098a7b2"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classEAbstractAnalytic_1_1Block.html">EAbstractAnalytic::Block</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEAbstractAnalytic.html#a89408851e50af49aee5281141098a7b2">makeResult</a> () const</td></tr>
<tr class="separator:a89408851e50af49aee5281141098a7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065ce11027b4bfcb4b7c3122133adf4b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEAbstractAnalytic_1_1Serial.html">EAbstractAnalytic::Serial</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEAbstractAnalytic.html#a065ce11027b4bfcb4b7c3122133adf4b">makeSerial</a> ()</td></tr>
<tr class="separator:a065ce11027b4bfcb4b7c3122133adf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b228e7420b3d5a4cbf7cdce8a84060"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classEAbstractAnalytic_1_1OpenCL.html">EAbstractAnalytic::OpenCL</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEAbstractAnalytic.html#ac2b228e7420b3d5a4cbf7cdce8a84060">makeOpenCL</a> ()</td></tr>
<tr class="separator:ac2b228e7420b3d5a4cbf7cdce8a84060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3aff988b0b869dd337c15e1d02a56e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEAbstractAnalytic.html#a4c3aff988b0b869dd337c15e1d02a56e">initialize</a> ()</td></tr>
<tr class="separator:a4c3aff988b0b869dd337c15e1d02a56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7091d38d81ed3d31fe47fde4762085c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEAbstractAnalytic.html#a7091d38d81ed3d31fe47fde4762085c1">initializeOutputs</a> ()</td></tr>
<tr class="separator:a7091d38d81ed3d31fe47fde4762085c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9568d815fa32833e4911d9fdd975189b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEAbstractAnalytic.html#a9568d815fa32833e4911d9fdd975189b">finish</a> ()</td></tr>
<tr class="separator:a9568d815fa32833e4911d9fdd975189b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ada04f3a7a65843c6f222dc4791638c72"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEAbstractAnalytic.html#ada04f3a7a65843c6f222dc4791638c72">isMaster</a> ()</td></tr>
<tr class="separator:ada04f3a7a65843c6f222dc4791638c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This represents an analytic process for the ACE system. Because of the complexity of an analytic its tasks are divided into multiple sub classes. This class is responsible for making all other sub classes, making blocks of work, reading blocks of results, initialization, and finishing the analytic. An implementation of this class must do all of these things. The work of an analytic is designed to be split up into individual blocks of work. This class creates these blocks of work and then reads in the corresponding blocks containing the results of the work. To accommodate very simple analytic types an implementation of this class can choose to not produce work blocks which causes the process interface to be called with empty generic result blocks. A simple analytic only supports single process serial mode for operation and does not override the serial or <a class="el" href="classEAbstractAnalytic_1_1OpenCL.html">OpenCL</a> methods. Simple analytic types also do not need to implement any interfaces for making blocks since they are not used. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9568d815fa32833e4911d9fdd975189b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9568d815fa32833e4911d9fdd975189b">&#9670;&nbsp;</a></span>finish()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EAbstractAnalytic::finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This interface is called to finish this analytic. This is called at the very end after every other interface call. The default implementation does nothing. </p>

</div>
</div>
<a id="a4c3aff988b0b869dd337c15e1d02a56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3aff988b0b869dd337c15e1d02a56e">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EAbstractAnalytic::initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This interface initializes this analytic. This is called only once before any other interface is called for this analytic. The default implementation does nothing. </p>

</div>
</div>
<a id="a7091d38d81ed3d31fe47fde4762085c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7091d38d81ed3d31fe47fde4762085c1">&#9670;&nbsp;</a></span>initializeOutputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void EAbstractAnalytic::initializeOutputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This interface initializes any outputs for this analytic. This is called only once before any other interface is called for this analytic. This is only called for analytic objects that will process output result blocks. The default implementation does nothing. </p>

</div>
</div>
<a id="ada04f3a7a65843c6f222dc4791638c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada04f3a7a65843c6f222dc4791638c72">&#9670;&nbsp;</a></span>isMaster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool EAbstractAnalytic::isMaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tests if this is the master node in an MPI run. If this is not an MPI run then this will also return true.</p>
<dl class="section return"><dt>Returns</dt><dd>True if this is the master node of an MPI run or this is not running in MPI mode, otherwise false is returned. </dd></dl>

</div>
</div>
<a id="ab08ff1d8b6841ae84f7eae6a0eb724b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08ff1d8b6841ae84f7eae6a0eb724b6">&#9670;&nbsp;</a></span>makeInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classEAbstractAnalytic_1_1Input.html">EAbstractAnalytic::Input</a>* EAbstractAnalytic::makeInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This interface makes a new input object and returns its pointer. The returned input object must have this abstract analytic set as its parent.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new input object. </dd></dl>

</div>
</div>
<a id="ac2b228e7420b3d5a4cbf7cdce8a84060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b228e7420b3d5a4cbf7cdce8a84060">&#9670;&nbsp;</a></span>makeOpenCL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEAbstractAnalytic_1_1OpenCL.html">EAbstractAnalytic::OpenCL</a> * EAbstractAnalytic::makeOpenCL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This interface makes a new <a class="el" href="classEAbstractAnalytic_1_1OpenCL.html">OpenCL</a> object and returns its pointer. If this analytic type does not support <a class="el" href="classEAbstractAnalytic_1_1OpenCL.html">OpenCL</a> then a null pointer is returned. The default implementation returns a null pointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new <a class="el" href="classEAbstractAnalytic_1_1OpenCL.html">OpenCL</a> object or null if this analytic does not support <a class="el" href="classEAbstractAnalytic_1_1OpenCL.html">OpenCL</a>. </dd></dl>

</div>
</div>
<a id="a89408851e50af49aee5281141098a7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89408851e50af49aee5281141098a7b2">&#9670;&nbsp;</a></span>makeResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classEAbstractAnalytic_1_1Block.html">EAbstractAnalytic::Block</a> &gt; EAbstractAnalytic::makeResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This interface creates an empty and uninitialized result block. This is used by MPI and chunk runs for reading in work blocks from byte arrays. The default implementation throws an exception because this should never be called if it is not implemented by an analytic.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer uninitialized result block. </dd></dl>

</div>
</div>
<a id="a065ce11027b4bfcb4b7c3122133adf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065ce11027b4bfcb4b7c3122133adf4b">&#9670;&nbsp;</a></span>makeSerial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEAbstractAnalytic_1_1Serial.html">EAbstractAnalytic::Serial</a> * EAbstractAnalytic::makeSerial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This interface makes a new serial object and returns its pointer. If this analytic type does not support serial then a null pointer is returned. The default implementation returns a null pointer.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to new serial object or null if no serial support. </dd></dl>

</div>
</div>
<a id="a36728ab171737200297c38d6b966010e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36728ab171737200297c38d6b966010e">&#9670;&nbsp;</a></span>makeWork() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classEAbstractAnalytic_1_1Block.html">EAbstractAnalytic::Block</a> &gt; EAbstractAnalytic::makeWork </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This interface creates and returns a work block for this analytic with the given index. The default implementation throws an exception because this should never be called if it is not implemented by an analytic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index used to make the block of work.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer new work block with the given index. </dd></dl>

</div>
</div>
<a id="a0d9057610ae34ff638d9641f411ba7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9057610ae34ff638d9641f411ba7c0">&#9670;&nbsp;</a></span>makeWork() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classEAbstractAnalytic_1_1Block.html">EAbstractAnalytic::Block</a> &gt; EAbstractAnalytic::makeWork </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This interface creates an empty and uninitialized work block. This is used by MPI and chunk runs for reading in work blocks from byte arrays. The default implementation throws an exception because this should never be called if it is not implemented by an analytic.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer uninitialized work block. </dd></dl>

</div>
</div>
<a id="a946ac98bb29b6c5e1d9f167511ae432e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946ac98bb29b6c5e1d9f167511ae432e">&#9670;&nbsp;</a></span>process()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void EAbstractAnalytic::process </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classEAbstractAnalytic_1_1Block.html">EAbstractAnalytic::Block</a> *&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This interface processes the given result block. The order of indexes called will always be in order starting at 0. If this analytic does not produce work blocks then the given block is a generic and empty block which only contains the index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>Pointer to result block that is processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab518e9fe6dfd8f0fc82c15986ff0d873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab518e9fe6dfd8f0fc82c15986ff0d873">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int EAbstractAnalytic::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This interface returns the total number of blocks this analytic must process as steps or blocks of work. If this analytic produces no work blocks then this means the number of times the process interface is called.</p>
<dl class="section return"><dt>Returns</dt><dd>Total number of blocks or steps that this analytic must work on. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="eabstractanalytic_8h_source.html">eabstractanalytic.h</a></li>
<li>eabstractanalytic.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
